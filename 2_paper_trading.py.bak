#!/usr/bin/env python3
"""
TOOL 2: PAPER TRADING SIMULATOR
"""

import ccxt
import pandas as pd
import time
import json
from datetime import datetime
from colorama import Fore, Style, init
from tabulate import tabulate
import os

init(autoreset=True)

class PaperTradingBot:
    def __init__(self, initial_balance=10000, symbols=['BTC/USDT', 'ETH/USDT']):
        self.exchange = ccxt.gate({'enableRateLimit': True})
        self.symbols = symbols
        self.initial_balance = initial_balance
        self.balance = initial_balance
        self.positions = []
        self.trade_history = []
        self.stop_loss_pct = 0.001
        self.take_profit_pct = 0.0015
        self.max_trades_per_day = 10
        self.daily_trades = 0
        self.daily_pnl = 0
        
    def calculate_rsi(self, prices, period=7):
        if len(prices) < period + 1:
            return 50
        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]
        gains = [d if d > 0 else 0 for d in deltas]
        losses = [-d if d < 0 else 0 for d in deltas]
        avg_gain = sum(gains[-period:]) / period
        avg_loss = sum(losses[-period:]) / period
        if avg_loss == 0:
            return 100
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))
    
    def get_orderbook_imbalance(self, symbol):
        try:
            orderbook = self.exchange.fetch_order_book(symbol, limit=10)
            bid_volume = sum([bid[1] for bid in orderbook['bids'][:5]])
            ask_volume = sum([ask[1] for ask in orderbook['asks'][:5]])
            total = bid_volume + ask_volume
            return (bid_volume - ask_volume) / total if total > 0 else 0
        except:
            return 0
    
    def analyze_opportunity(self, symbol):
        try:
            ohlcv = self.exchange.fetch_ohlcv(symbol, '1m', limit=50)
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            current_price = df['close'].iloc[-1]
            prices = df['close'].tolist()
            rsi = self.calculate_rsi(prices)
            
            avg_volume = df['volume'].tail(10).mean()
            current_volume = df['volume'].iloc[-1]
            volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1
            
            df['vwap'] = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()
            vwap = df['vwap'].iloc[-1]
            dist_vwap = ((current_price - vwap) / vwap) * 100
            
            ob_imbalance = self.get_orderbook_imbalance(symbol)
            price_change = ((current_price - df['close'].iloc[-2]) / df['close'].iloc[-2]) * 100
            
            return {
                'symbol': symbol, 'price': current_price, 'rsi': rsi,
                'volume_ratio': volume_ratio, 'dist_vwap': dist_vwap,
                'ob_imbalance': ob_imbalance, 'price_change': price_change
            }
        except Exception as e:
            print(f"{Fore.RED}Error: {e}")
            return None
    
    def should_buy(self, analysis):
        score = 0
        if analysis['rsi'] < 35:
            score += 2
        if analysis['ob_imbalance'] > 0.3:
            score += 2
        if analysis['volume_ratio'] > 1.5:
            score += 1
        if -0.1 < analysis['dist_vwap'] < 0.1:
            score += 1
        if analysis['price_change'] > 0.05:
            score += 1
        return score >= 4
    
    def open_position(self, symbol, side, price, analysis):
        risk_amount = self.balance * 0.01
        stop_distance = price * self.stop_loss_pct
        quantity = risk_amount / stop_distance
        position_value = quantity * price
        
        if position_value > self.balance * 0.3:
            return False
        
        position = {
            'symbol': symbol, 'side': side, 'entry_price': price, 'quantity': quantity,
            'stop_loss': price * (1 - self.stop_loss_pct) if side == 'BUY' else price * (1 + self.stop_loss_pct),
            'take_profit': price * (1 + self.take_profit_pct) if side == 'BUY' else price * (1 - self.take_profit_pct),
            'entry_time': datetime.now()
        }
        
        self.positions.append(position)
        self.balance -= position_value
        
        print(f"\n{Fore.GREEN}{'='*80}")
        print(f"OPENED POSITION #{len(self.trade_history) + 1}")
        print(f"Symbol: {symbol} | Side: {side} | Price: ${price:,.2f}")
        print(f"Stop: ${position['stop_loss']:,.2f} | Target: ${position['take_profit']:,.2f}")
        print(f"{Fore.GREEN}{'='*80}\n")
        
        self.daily_trades += 1
        return True
    
    def close_position(self, position, current_price, reason):
        entry_price = position['entry_price']
        quantity = position['quantity']
        
        if position['side'] == 'BUY':
            pnl = (current_price - entry_price) * quantity
        else:
            pnl = (entry_price - current_price) * quantity
        
        fees = (entry_price * quantity * 0.001) + (current_price * quantity * 0.001)
        net_pnl = pnl - fees
        
        position_value = current_price * quantity
        self.balance += position_value + net_pnl
        self.daily_pnl += net_pnl
        
        trade = {
            'symbol': position['symbol'], 'side': position['side'],
            'entry_price': entry_price, 'exit_price': current_price,
            'pnl': net_pnl, 'reason': reason, 'exit_time': datetime.now()
        }
        self.trade_history.append(trade)
        
        color = Fore.GREEN if net_pnl > 0 else Fore.RED
        print(f"\n{color}{'='*80}")
        print(f"CLOSED - {reason}")
        print(f"P&L: ${net_pnl:,.2f} | Balance: ${self.balance:,.2f}")
        print(f"{color}{'='*80}\n")
        
        self.positions.remove(position)
    
    def check_positions(self):
        for position in self.positions[:]:
            try:
                ticker = self.exchange.fetch_ticker(position['symbol'])
                current_price = ticker['last']
                
                if position['side'] == 'BUY' and current_price <= position['stop_loss']:
                    self.close_position(position, current_price, "STOP LOSS")
                elif position['side'] == 'BUY' and current_price >= position['take_profit']:
                    self.close_position(position, current_price, "TAKE PROFIT")
                elif (datetime.now() - position['entry_time']).total_seconds() > 300:
                    self.close_position(position, current_price, "TIMEOUT")
            except Exception as e:
                print(f"{Fore.RED}Error: {e}")
    
    def display_stats(self):
        if not self.trade_history:
            return
        
        wins = [t for t in self.trade_history if t['pnl'] > 0]
        total = len(self.trade_history)
        win_rate = (len(wins) / total * 100) if total > 0 else 0
        total_pnl = sum(t['pnl'] for t in self.trade_history)
        roi = ((self.balance - self.initial_balance) / self.initial_balance) * 100
        
        print(f"\n{Fore.CYAN}{'='*80}")
        print(f"{Fore.YELLOW}PERFORMANCE STATISTICS")
        print(f"{Fore.CYAN}{'='*80}")
        
        stats = [
            ['Balance', f"${self.balance:,.2f}"],
            ['Total P&L', f"${total_pnl:,.2f}"],
            ['ROI', f"{roi:+.2f}%"],
            ['Total Trades', total],
            ['Wins', len(wins)],
            ['Win Rate', f"{win_rate:.1f}%"]
        ]
        print(tabulate(stats, headers=['Metric', 'Value'], tablefmt='grid'))
        print(f"{Fore.CYAN}{'='*80}\n")
    
    def run(self, interval=30):
        print(f"{Fore.CYAN}{'='*80}")
        print(f"{Fore.YELLOW}PAPER TRADING SIMULATOR")
        print(f"{Fore.CYAN}{'='*80}")
        print(f"Balance: ${self.initial_balance:,.2f} (VIRTUAL)")
        print("Press Ctrl+C to stop\n")
        
        try:
            while True:
                print(f"{Fore.MAGENTA}[{datetime.now().strftime('%H:%M:%S')}]")
                
                if self.positions:
                    self.check_positions()
                
                if self.daily_trades < self.max_trades_per_day and len(self.positions) < 3:
                    for symbol in self.symbols:
                        analysis = self.analyze_opportunity(symbol)
                        if analysis and self.should_buy(analysis):
                            self.open_position(symbol, 'BUY', analysis['price'], analysis)
                        time.sleep(1)
                
                self.display_stats()
                
                if self.positions:
                    print(f"{Fore.CYAN}Open Positions: {len(self.positions)}")
                
                time.sleep(interval)
        except KeyboardInterrupt:
            print(f"\n{Fore.YELLOW}Stopped.")
            self.display_stats()

if __name__ == "__main__":
    bot = PaperTradingBot(initial_balance=10000)
    bot.run(interval=30)
